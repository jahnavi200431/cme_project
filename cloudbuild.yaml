options:
  logging: 'CLOUD_LOGGING_ONLY'
   # 20 minutes

serviceAccount: 'projects/my-project-app-477009/serviceAccounts/433503387155-compute@developer.gserviceaccount.com'

steps:
  # ----------------------------------------------------------------------------
  # 1) Build the Docker image
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build Docker Image'
    args:
      - 'build'
      - '-t'
      - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'
      - '.'
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

  # ----------------------------------------------------------------------------
  # 2) Push the Docker image to Artifact Registry
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push Docker Image'
    args:
      - 'push'
      - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'

  # ----------------------------------------------------------------------------
  # 3) Deploy to GKE: update manifest image, apply manifests, wait for rollout
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Deploy to GKE'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail
        echo "üì¶ Starting deployment to GKE for project my-project-app-477009..."

        # Authenticate kubectl to the cluster
        gcloud container clusters get-credentials product-gke-cluster \
          --zone=us-central1-a \
          --project=my-project-app-477009

        echo "üîß Updating image reference in k8s/deployment.yaml..."
        # Replace the image: line in the deployment manifest with the artifact registry image.
        sed -i.bak "s|\(image:[[:space:]]*\).*|\1us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest|g" k8s/deployment.yaml

        echo "üöÄ Applying Kubernetes manifests..."
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/service.yaml || true
        kubectl apply -f k8s/ingress.yaml || true

        echo "‚è≥ Waiting for deployment rollout to finish (timeout: 180s)..."
        kubectl rollout status deployment/gke-rest-api --timeout=180s || (echo "‚ö†Ô∏è Rollout did not finish within timeout." && kubectl get pods -o wide && exit 1)

        echo "‚úÖ Deployment applied and rollout complete."
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

  # ----------------------------------------------------------------------------
   # 4) Post-deployment checks: ensure LB IP, run health checks and integration tests
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Post-Deployment Checks & Integration Tests'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail
        echo "üîç Running post-deployment checks and integration tests..."

        # wait for LoadBalancer IP
        LB_IP="34.133.250.137"
        MAX_RETRIES=12
        RETRY=0
        while [ -z "$$LB_IP" ] && [ $$RETRY -lt $$MAX_RETRIES ]; do
          echo "Waiting for LoadBalancer IP... (retry $$RETRY/$$MAX_RETRIES)"
          sleep 10
          LB_IP=$$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --ignore-not-found || true)
          RETRY=$$((RETRY+1))
        done

        if [ -z "$$LB_IP" ]; then
          echo "‚ùå LoadBalancer IP not found. Gathering diagnostics..."
          kubectl get svc gke-rest-api-service -o yaml || true
          kubectl describe svc gke-rest-api-service || true
          kubectl get pods -l app=gke-rest-api -o wide || true
          kubectl describe deployment gke-rest-api || true
          kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 50 || true
          exit 1
        fi

        echo "‚úÖ LoadBalancer IP: $$LB_IP"

        # simple endpoint smoke check before running integration tests
        echo "‚è≥ Performing simple /products endpoint health check..."
        for i in $$(seq 1 8); do
          http_status=$$(curl -s -o /dev/null -w "%{http_code}" "http://$$LB_IP:80/products" || echo "000")
          echo "Attempt $$i: HTTP $$http_status"
          if [ "$$http_status" = "200" ]; then
            echo "‚úÖ /products returned 200"
            break
          fi
          sleep 5
        done

        if [ "$$http_status" != "200" ]; then
          echo "‚ùå /products endpoint did not return 200 after retries. Gathering diagnostics..."
          kubectl get pods -l app=gke-rest-api -o wide || true
          kubectl describe deployment gke-rest-api || true
          kubectl describe svc gke-rest-api-service || true
          kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 50 || true
          exit 1
        fi

        # Run integration test script from the repo (script returns non-zero on failure)
        echo "üß™ Running integration tests script tests/integration_test.sh"
        chmod +x tests/integration_test.sh || true
        LB="$$LB_IP" bash tests/integration_test.sh

        echo "‚úÖ Integration tests passed."
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

  # ----------------------------------------------------------------------------
  # 5) Create / Update synthetic uptime checks for key API endpoints (optional)
  #    Controlled by substitution _CREATE_UPTIME_CHECK (set to "true" in trigger or gcloud submit)
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Create Synthetic Uptime Checks'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail

        if [ "${_CREATE_UPTIME_CHECK:-false}" != "true" ]; then
          echo "Skipping synthetic uptime-check creation (set _CREATE_UPTIME_CHECK=true to enable)."
          exit 0
        fi

        echo "üîî Creating/updating synthetic uptime checks for key endpoints..."

        # Resolve LB IP / Ingress address (prefer substitution then cluster resources)
        LB_IP="${_LB_IP:-}"
        if [ -z "$LB_IP" ]; then
          LB_IP=$$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --ignore-not-found || true)
        fi
        if [ -z "$LB_IP" ]; then
          LB_IP=$$(kubectl get ingress product-api-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --ignore-not-found || true)
        fi
        if [ -z "$LB_IP" ]; then
          LB_IP=$$(kubectl get ingress product-api-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' --ignore-not-found || true)
        fi

        if [ -z "$LB_IP" ]; then
          echo "LB IP / Ingress address not found; skipping synthetic checks creation."
          exit 0
        fi

        echo "Resolved host for synthetic checks: $LB_IP"

        # Ensure the monitoring script is available & executable
        chmod +x monitoring/create_uptime_checks.sh || true

        # Create checks for the key endpoints: /products, /health, /metrics
        ./monitoring/create_uptime_checks.sh \
          --project=my-project-app-477009 \
          --host="$LB_IP" \
          --paths="/products,/health,/metrics" \
          --name-prefix="gke-rest-api" \
          --notification-channel="${_NOTIF_CHANNEL_ID:-}"
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

# ----------------------------------------------------------------------------
# Images built by this pipeline to be stored in Artifact Registry
# ----------------------------------------------------------------------------
images:
  - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'

