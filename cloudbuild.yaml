options:
  logging: 'CLOUD_LOGGING_ONLY'
  # timeout: '1200s'  # Uncomment if you need a longer build timeout

steps:
- name: 'gcr.io/cloud-builders/docker'
  id: 'Build Docker Image'
  args:
    - 'build'
    - '-t'
    - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'
    - '.'

- name: 'gcr.io/cloud-builders/docker'
  id: 'Push Docker Image'
  args:
    - 'push'
    - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'

- name: 'gcr.io/cloud-builders/gcloud'
  id: 'Deploy to GKE'
  entrypoint: 'bash'
  args:
    - '-c'
    - |
      set -euxo pipefail
      echo "üì¶ Starting deployment to GKE for project my-project-app-477009..."

      # Ensure gcloud is using the right project (helpful for debugging)
      gcloud config set project my-project-app-477009

      echo "üîê Getting credentials for GKE cluster 'product-gke-cluster'..."
      if ! gcloud container clusters get-credentials product-gke-cluster --zone=us-central1-a --project=my-project-app-477009; then
        echo "‚ùå Failed to get GKE credentials. Verify the cluster name, zone, project, and that the Cloud Build SA has container.getCredentials rights."
        exit 1
      fi

      echo "üîß Replacing COMMIT_SHA_PLACEHOLDER in k8s/deployment.yaml with latest..."
      sed -i "s|COMMIT_SHA_PLACEHOLDER|latest|g" k8s/deployment.yaml

      echo "üöÄ Applying Kubernetes manifests..."
      kubectl apply -f k8s/deployment.yaml
      kubectl apply -f k8s/service.yaml

      # Wait for rollout to finish (update deployment name if different)
      kubectl rollout status deployment/gke-rest-api --timeout=120s || { echo "‚ùå Rollout failed or timed out"; kubectl describe deployment gke-rest-api || true; kubectl get pods -o wide || true; exit 1; }

      echo "‚úÖ Deployment applied and rollout completed."

  env:
    - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

- name: 'gcr.io/cloud-builders/gcloud'
  id: 'Post-Deployment Checks'
  entrypoint: 'bash'
  args:
    - '-c'
    - |
      set -euxo pipefail
      echo "üîç Running basic health check on deployed service..."

      LB_IP=""
      MAX_RETRIES=10
      RETRY_COUNT=0

      while [ -z "$$LB_IP" ] && [ $$RETRY_COUNT -lt $$MAX_RETRIES ]; do
        echo "Waiting for LoadBalancer IP... (Retry $$RETRY_COUNT/$$MAX_RETRIES)"
        sleep 10
        LB_IP=$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --ignore-not-found 2>/dev/null || true)
        RETRY_COUNT=$((RETRY_COUNT + 1))
      done

      if [ -z "$$LB_IP" ]; then
        echo "‚ùå LoadBalancer IP not found after $$MAX_RETRIES retries. Cannot perform health check."
        kubectl get svc gke-rest-api-service -o yaml || true
        exit 1
      fi

      echo "‚úÖ LoadBalancer IP found: $$LB_IP"
      echo "Checking application endpoint at http://$$LB_IP/products ..."

      sleep 15

      if curl -f "http://$$LB_IP/products"; then
        echo "‚úÖ Health check passed: Received a successful response from /products."
      else
        echo "‚ùå Health check failed: /products did not return 2xx/3xx."
        exit 1
      fi

images:
  - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'
