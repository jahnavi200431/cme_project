options:
  logging: 'CLOUD_LOGGING_ONLY'
    # 20 minutes

serviceAccount: 'projects/my-project-app-477009/serviceAccounts/433503387155-compute@developer.gserviceaccount.com'

steps:
  # ----------------------------------------------------------------------------
  # 1) Build the Docker image
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build Docker Image'
    args:
      - 'build'
      - '-t'
      - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'
      - '.'
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

  # ----------------------------------------------------------------------------
  # 2) Push the Docker image to Artifact Registry
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push Docker Image'
    args:
      - 'push'
      - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'

  # ----------------------------------------------------------------------------
  # 3) Deploy to GKE: update manifest image, apply manifests, wait for rollout
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Deploy to GKE'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "üì¶ Starting deployment to GKE for project my-project-app-477009..."

        # Authenticate kubectl to the cluster
        gcloud container clusters get-credentials product-gke-cluster \
          --zone=us-central1-a \
          --project=my-project-app-477009

        echo "üîß Updating image reference in k8s/deployment.yaml..."
        # Replace the image: line in the deployment manifest with the artifact registry image.
        # This matches the "image:" key and replaces the value. Keep a backup with .bak for easier debugging.
        sed -i.bak "s|\(image:[[:space:]]*\).*|\1us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest|g" k8s/deployment.yaml

        echo "üöÄ Applying Kubernetes manifests..."
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/service.yaml

        echo "‚è≥ Waiting for deployment rollout to finish (timeout: 80s)..."
        kubectl rollout status deployment/gke-rest-api --timeout=80s || (echo "‚ö†Ô∏è Rollout did not finish within timeout." && kubectl get pods -o wide && exit 1)

        echo "‚úÖ Deployment applied and rollout complete."
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

  # ----------------------------------------------------------------------------
  # 4) Post-deployment checks: ensure LB IP, run health checks and integration tests
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Post-Deployment Checks & Integration Tests'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail
        echo "üîç Running post-deployment checks and integration tests..."

        # wait for LoadBalancer IP (use $$ to prevent Cloud Build substitution)
        LB_IP="34.133.250.137"
        MAX_RETRIES=12
        RETRY=0
        while [ -z "$$LB_IP" ] && [ $$RETRY -lt $$MAX_RETRIES ]; do
          echo "Waiting for LoadBalancer IP... (retry $$RETRY/$$MAX_RETRIES)"
          sleep 10
          LB_IP=$$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --ignore-not-found || true)
          RETRY=$$((RETRY+1))
        done

        if [ -z "$$LB_IP" ]; then
          echo "‚ùå LoadBalancer IP not found. Gathering diagnostics..."
          kubectl get svc gke-rest-api-service -o yaml || true
          kubectl describe svc gke-rest-api-service || true
          kubectl get pods -l app=gke-rest-api -o wide || true
          kubectl describe deployment gke-rest-api || true
          kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 50 || true
          exit 1
        fi

        echo "‚úÖ LoadBalancer IP: $$LB_IP"

        # simple endpoint smoke check before running integration tests
        echo "‚è≥ Performing simple /products endpoint health check..."
        for i in $$(seq 1 8); do
          http_status=$$(curl -s -o /dev/null -w "%{http_code}" "http://$$LB_IP:80/products" || echo "000")
          echo "Attempt $$i: HTTP $$http_status"
          if [ "$$http_status" = "200" ]; then
            echo "‚úÖ /products returned 200"
            break
          fi
          sleep 5
        done

        if [ "$$http_status" != "200" ]; then
          echo "‚ùå /products endpoint did not return 200 after retries. Gathering diagnostics..."
          kubectl get pods -l app=gke-rest-api -o wide || true
          kubectl describe deployment gke-rest-api || true
          kubectl describe svc gke-rest-api-service || true
          kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 50 || true
          exit 1
        fi

        # Run integration test script from the repo (script returns non-zero on failure)
        echo "üß™ Running integration tests script tests/integration_test.sh"
        chmod +x tests/integration_test.sh || true
        LB="$$LB_IP" bash tests/integration_test.sh

        echo "‚úÖ Integration tests passed."
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

  # ----------------------------------------------------------------------------
  # 5) Create / Update Cloud Monitoring uptime check (optional)
  #    Controlled by substitution _CREATE_UPTIME_CHECK (set to "true" in trigger or gcloud submit)
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Create Uptime Check'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail
        # default behavior: run if substitution _CREATE_UPTIME_CHECK is true (set it in your trigger)
        if [ "${_CREATE_UPTIME_CHECK:-false}" != "true" ]; then
          echo "Skipping uptime-check creation (set _CREATE_UPTIME_CHECK=true to enable)."
          exit 0
        fi

        echo "üîî Creating/updating uptime check using monitoring/create_uptime_check.sh..."

        # Resolve LB IP (use $$ to prevent Cloud Build expanding)
        LB_IP=$$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --ignore-not-found || true)
        if [ -z "$$LB_IP" ]; then
          echo "LB IP not found; skipping uptime-check creation"
          exit 0
        fi

        # Ensure script is executable and run it with provided notification channel
        chmod +x monitoring/create_uptime_check.sh || true

        ./monitoring/create_uptime_check.sh \
          --project=my-project-app-477009 \
          --lb-ip="$$LB_IP" \
          --notification-channel="projects/my-project-app-477009/notificationChannels/12064618237516244045"
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

# ----------------------------------------------------------------------------
# Images built by this pipeline to be stored in Artifact Registry
# ----------------------------------------------------------------------------
images:
  - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'
