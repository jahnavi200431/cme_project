

options:
  logging: 'CLOUD_LOGGING_ONLY'
    # 20 minutes

# Cloud Build will run steps using this service account
serviceAccount: 'projects/my-project-app-477009/serviceAccounts/433503387155-compute@developer.gserviceaccount.com'

steps:
  # ----------------------------------------------------------------------------
  # 1) Build the Docker image
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build Docker Image'
    args:
      - 'build'
      - '-t'
      - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'
      - '.'
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

  # ----------------------------------------------------------------------------
  # 2) Push the Docker image to Artifact Registry
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push Docker Image'
    args:
      - 'push'
      - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'

  # ----------------------------------------------------------------------------
  # 3) Deploy to GKE: update manifest image, apply manifests, wait for rollout
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Deploy to GKE'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "üì¶ Starting deployment to GKE for project my-project-app-477009..."

        # Authenticate kubectl to the cluster
        gcloud container clusters get-credentials product-gke-cluster \
          --zone=us-central1-a \
          --project=my-project-app-477009

        echo "üîß Updating image reference in k8s/deployment.yaml..."
        # Replace the image: line in the deployment manifest with the artifact registry image.
        # This matches the "image:" key and replaces the value. Keep a backup with .bak for easier debugging.
        sed -i.bak "s|\(image:[[:space:]]*\).*|\1us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest|g" k8s/deployment.yaml

        echo "üöÄ Applying Kubernetes manifests..."
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/service.yaml

        echo "‚è≥ Waiting for deployment rollout to finish (timeout: 80s)..."
        kubectl rollout status deployment/gke-rest-api --timeout=80s || (echo "‚ö†Ô∏è Rollout did not finish within timeout." && kubectl get pods -o wide && exit 1)

        echo "‚úÖ Deployment applied and rollout complete."
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

  # ----------------------------------------------------------------------------
  # 4) Post-deployment checks: ensure LB IP, run health checks and integration tests
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Post-Deployment Checks & Integration Tests'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail
        echo "üîç Running post-deployment checks and integration tests..."

        # wait for LoadBalancer IP
        LB_IP="34.133.250.137"
        MAX_RETRIES=12
        RETRY=0
        while [ -z "$LB_IP" ] && [ $RETRY -lt $MAX_RETRIES ]; do
          echo "Waiting for LoadBalancer IP... (retry $RETRY/$MAX_RETRIES)"
          sleep 10
          LB_IP=$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --ignore-not-found || true)
          RETRY=$((RETRY+1))
        done

        if [ -z "$LB_IP" ]; then
          echo "‚ùå LoadBalancer IP not found. Gathering diagnostics..."
          kubectl get svc gke-rest-api-service -o yaml || true
          kubectl describe svc gke-rest-api-service || true
          kubectl get pods -l app=gke-rest-api -o wide || true
          kubectl describe deployment gke-rest-api || true
          kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 50 || true
          exit 1
        fi

        echo "‚úÖ LoadBalancer IP: $LB_IP"

        # simple endpoint smoke check before running integration tests
        echo "‚è≥ Performing simple /products endpoint health check..."
        for i in $(seq 1 8); do
          http_status=$(curl -s -o /dev/null -w "%{http_code}" "http://$LB_IP:80/products" || echo "000")
          echo "Attempt $i: HTTP $http_status"
          if [ "$http_status" = "200" ]; then
            echo "‚úÖ /products returned 200"
            break
          fi
          sleep 5
        done

        if [ "$http_status" != "200" ]; then
          echo "‚ùå /products endpoint did not return 200 after retries. Gathering diagnostics..."
          kubectl get pods -l app=gke-rest-api -o wide || true
          kubectl describe deployment gke-rest-api || true
          kubectl describe svc gke-rest-api-service || true
          kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 50 || true
          exit 1
        fi

        # Run integration test script from the repo (script returns non-zero on failure)
        echo "üß™ Running integration tests script tests/integration_test.sh"
        chmod +x tests/integration_test.sh || true
        LB="$LB_IP" bash tests/integration_test.sh

        echo "‚úÖ Integration tests passed."

        # Optionally create a Cloud Monitoring uptime check (only if trigger sets substitution _CREATE_UPTIME_CHECK=true)
        if [ "${_CREATE_UPTIME_CHECK:-false}" = "true" ]; then
          echo "üîî Creating/updating Cloud Monitoring uptime check for /products (requires proper IAM)"
          # This uses the alpha gcloud command; adjust as needed and ensure Cloud Monitoring API is enabled
          gcloud alpha monitoring uptime-checks create http \
            --project=my-project-app-477009 \
            --display-name="gke-rest-api-products" \
            --host="$LB_IP" \
            --path="/products" \
            --port=80 \
            --http-check-response-code=200 \
            --timeout=10s \
            --period=300s || echo "‚ö†Ô∏è Could not create uptime check (insufficient permissions or alpha APIs not enabled)."
        else
          echo "Monitoring creation skipped (set _CREATE_UPTIME_CHECK=true to enable)."
        fi
        echo "‚úÖ Health check passed: endpoint returned success."
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

# ----------------------------------------------------------------------------
# Images built by this pipeline to be stored in Artifact Registry
# ----------------------------------------------------------------------------
images:
  - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'
