options:
  logging: CLOUD_LOGGING_ONLY

serviceAccount: "projects/my-project-app-477009/serviceAccounts/433503387155-compute@developer.gserviceaccount.com"

substitutions:
  _TAG: $SHORT_SHA
  _IMAGE: "us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api"

steps:
  # ----------------------------------------------------------
  # 1) Install Terraform
  # ----------------------------------------------------------
  - name: hashicorp/terraform:1.6.6
    entrypoint: "sh"
    id: "Terraform Init & Apply"
    args:
      - "-c"
      - |
        cd infra1
        echo "üîß Initializing Terraform..."
        terraform init -input=false

        echo "üìÑ Planning Terraform..."
        terraform plan -out=tfplan -input=false

        echo "üöÄ Applying Terraform..."
        terraform apply -input=false -auto-approve tfplan

  # ----------------------------------------------------------
  # 2) Build Docker Image with UNIQUE TAG
  # ----------------------------------------------------------
  - name: gcr.io/cloud-builders/docker
    id: "Build Docker Image"
    args:
      [
        "build",
        "-t",
        "${_IMAGE}:${_TAG}",
        "."
      ]

  # ----------------------------------------------------------
  # 3) Push Docker image to Artifact Registry
  # ----------------------------------------------------------
  - name: gcr.io/cloud-builders/docker
    id: "Push Docker Image"
    args:
      [
        "push",
        "${_IMAGE}:${_TAG}"
      ]

  # ----------------------------------------------------------
  # 4) Deploy to GKE
  # ----------------------------------------------------------
  - name: "gcr.io/cloud-builders/gcloud"
    id: "Deploy to GKE"
    entrypoint: "bash"
    args:
      - "-c"
      - |
        echo "üöÄ Starting deployment to GKE..."

        gcloud container clusters get-credentials product-gke-cluster \
          --zone=us-central1-a \
          --project=my-project-app-477009

        echo "üîÑ Updating Deployment with new image: ${_IMAGE}:${_TAG}"

        kubectl set image deployment/gke-rest-api \
          gke-rest-api=${_IMAGE}:${_TAG}

        echo "‚è≥ Waiting for rollout..."
        kubectl rollout status deployment/gke-rest-api --timeout=120s || (
          echo "‚ùå Rollout failed"
          kubectl describe deployment gke-rest-api
          kubectl get pods -o wide
          exit 1
        )

  # ----------------------------------------------------------
  # 5) Post-deployment checks & integration tests
  # ----------------------------------------------------------
  - name: "gcr.io/cloud-builders/gcloud"
    id: "Post-Deployment Checks & Integration Tests"
    entrypoint: "bash"
    args:
      - "-c"
      - |
        set -euo pipefail
        echo "üîç Running post-deployment checks..."

        echo "Fetching Load Balancer IP..."
        LB_IP=$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

        echo "LoadBalancer IP: $LB_IP"

        echo "Checking /products endpoint..."
        for i in $(seq 1 10); do
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://$LB_IP/products")
          echo "Attempt $i ‚Üí HTTP $STATUS"
          [ "$STATUS" = "200" ] && echo "‚úî Healthy" && break
          sleep 5
        done

        if [ "$STATUS" != "200" ]; then
          echo "‚ùå /products endpoint failing"
          kubectl get pods -l app=gke-rest-api -o wide
          kubectl describe deployment gke-rest-api
          exit 1
        fi

        echo "üß™ Running integration tests..."
        chmod +x tests/integration_test.sh
        LB="$LB_IP" bash tests/integration_test.sh
        echo "‚úî Integration tests passed"

  # ----------------------------------------------------------
  # 6) Synthetic uptime checks
  # ----------------------------------------------------------
  - name: "gcr.io/cloud-builders/gcloud"
    id: "Create Synthetic Uptime Checks"
    entrypoint: "bash"
    args:
      - "-c"
      - |
        set -euo pipefail
        if [ "${_CREATE_UPTIME_CHECK:-false}" != "true" ]; then
          echo "Skipping uptime-check creation."
          exit 0
        fi

        LB_IP=$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "Using $LB_IP for uptime checks"

        chmod +x monitoring/create_uptime_check.sh
        ./monitoring/create_uptime_check.sh \
          --project=my-project-app-477009 \
          --host="$LB_IP" \
          --paths="/products" \
          --name-prefix="gke-rest-api" \
          --notification-channel="projects/my-project-app-477009/notificationChannels/1434793113408835929"

images:
  - "${_IMAGE}:${_TAG}"
