# cloudbuild.yaml
steps:
# ------------------------------------------------------------------------------
# Build Phase
# ------------------------------------------------------------------------------
- name: 'gcr.io/cloud-builders/docker'
  id: 'Build Docker Image'
  args:
    - 'build'
    - '-t'
    - 'us-central1-docker.pkg.dev//my-artifact-repo/gke-rest-api:latest' # Tag with commit SHA
    - '.' # Build from current directory

- name: 'gcr.io/cloud-builders/docker'
  id: 'Push Docker Image'
  args:
    - 'push'
    - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest' # Push the tagged image

# ------------------------------------------------------------------------------
# Deploy Phase
# ------------------------------------------------------------------------------
# Use the cloudbuild-deployer service account for GKE deployment
# This step replaces the image placeholder in k8s/deployment.yaml and applies it
- name: 'gcr.io/cloud-builders/gcloud'
  id: 'Deploy to GKE'
  entrypoint: 'bash'
  args:
    - '-c'
    - |
      # Replace the image placeholder with the actual image tag
      sed -i "s|COMMIT_SHA_PLACEHOLDER|latest|g" k8s/deployment.yaml

      # Configure kubectl to use the correct cluster
      gcloud container clusters get-credentials product-gke-cluster --zone=us-central1 --project=my-project-app-477009

      # Apply the updated deployment manifest to GKE
      kubectl apply -f k8s/deployment.yaml

  # Specify the dedicated deployer service account for this step
  # This leverages the impersonation setup you did earlier
  serviceAccount: 'projects/my-project-app-477009/serviceAccounts/cloudbuild-deployer@my-project-app-477009.iam.gserviceaccount.com'
  env:
    - 'CLOUDSDK_COMPUTE_ZONE=us-central1' # Ensure zone is set for gcloud container clusters get-credentials

# ------------------------------------------------------------------------------
# Post-Deployment Checks (Example - requires a separate container/script for tests)
# ------------------------------------------------------------------------------
# This is a placeholder. You would replace this with actual test commands.
# For example, if you have a Python script for integration tests:
# - name: 'python' # Or a custom Docker image with your test runner
#   id: 'Run Integration Tests'
#   entrypoint: 'python'
#   args: ['tests/integration_tests.py', '--endpoint=http://your-load-balancer-ip/products']
#   # This step might also need specific service account permissions if it interacts with other GCP services
#   # For simplicity, we'll omit a full test step here, but it's crucial for a complete pipeline.
- name: 'gcr.io/cloud-builders/gcloud'
  id: 'Post-Deployment Check (Placeholder)'
  entrypoint: 'bash'
  args:
    - '-c'
    - |
      echo "Running simulated post-deployment checks..."
      # In a real scenario, you'd curl your deployed service's health endpoint
      # For example: curl -f http://<YOUR_LOAD_BALANCER_IP>/healthz
      # If the curl fails, exit with a non-zero status to fail the build.
      sleep 10 # Simulate test duration
      echo "Simulated checks passed."

# Define the images that will be built and pushed by this pipeline
images:
  - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'

options:
  # Set a longer timeout for builds, especially if tests are involved
  timeout: '1200s' # 20 minutes

