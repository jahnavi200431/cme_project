# Cloud Build pipeline for GKE REST API Deployment
# - Builds a Docker image
# - Pushes it to Artifact Registry
# - Updates the Deployment image (kubectl set image) to ensure the new image is used
# - Uses a rolling update strategy declared in the Deployment manifest (zero-downtime)
# - Waits for rollout, runs automated integration tests, and optionally creates a Cloud Monitoring uptime check
#
# Notes:
# - This pipeline contains a guard so it only runs for main/master branch (works with common triggers).
# - The deployment manifest contains liveness/readiness probes for health checks.
# - Integration tests are in tests/integration_test.sh and will run against the LoadBalancer IP.
# - Optionally set the substitution _CREATE_UPTIME_CHECK=true on the trigger to create a Monitoring uptime check.
options:
  logging: 'CLOUD_LOGGING_ONLY'
    # 20 minutes

serviceAccount: 'projects/my-project-app-477009/serviceAccounts/433503387155-compute@developer.gserviceaccount.com'

steps:
  # ----------------------------------------------------------------------------
  # 0) Guard: Only proceed when this build is for main or master branch
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Verify Branch'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "üîé Verifying branch / trigger context..."

        BR=""
        if [ -n "$BRANCH_NAME" ]; then
          BR="$BRANCH_NAME"
        fi

        if [ -z "$BR" ] && [ -n "$BRANCH_REF" ]; then
          BR=$(basename "$BRANCH_REF")
        fi

        if [ -z "$BR" ]; then
          echo "Branch not detected (BRANCH_NAME/BRANCH_REF not set). Proceeding with the build."
        else
          echo "Build triggered for branch: $BR"
          if ! echo "$BR" | egrep -q '^(main|master)$'; then
            echo "This pipeline only runs for the main or master branch. Skipping build steps."
            exit 0
          fi
        fi

  # ----------------------------------------------------------------------------
  # 1) Build the Docker image
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build Docker Image'
    args:
      - 'build'
      - '-t'
      - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'
      - '.'
    env:
      - 'CLOUDSDK_COMPUTE_ZONE=us-central1-a'

  # ----------------------------------------------------------------------------
  # 2) Push the Docker image to Artifact Registry
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push Docker Image'
    args:
      - 'push'
      - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'

  # ----------------------------------------------------------------------------
  # 3) Deploy to GKE: set image on the Deployment (safe) and wait for rolling update
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Deploy to GKE'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail
        IMAGE="us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest"

        echo "üì¶ Starting deployment to GKE for project my-project-app-477009..."
        gcloud container clusters get-credentials product-gke-cluster \
          --zone=us-central1-a \
          --project=my-project-app-477009

        echo "üîß Updating Deployment image using kubectl set image -> ${IMAGE}"
        kubectl -n default set image deployment/gke-rest-api gke-rest-api="${IMAGE}" --record

        echo "üöÄ Waiting for rolling update to complete (timeout: 180s)..."
        kubectl rollout status deployment/gke-rest-api --timeout=180s || (echo "‚ö†Ô∏è Rollout did not finish within timeout." && kubectl get pods -o wide && kubectl describe deployment gke-rest-api && exit 1)

        echo "‚úÖ Deployment update complete."

  # ----------------------------------------------------------------------------
  # 4) Post-deployment checks: ensure LB IP, run health checks and integration tests
  # ----------------------------------------------------------------------------
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Post-Deployment Checks & Integration Tests'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -euo pipefail
        echo "üîç Running post-deployment checks and integration tests..."

        # wait for LoadBalancer IP
        LB_IP=""
        MAX_RETRIES=12
        RETRY=0
        while [ -z "$LB_IP" ] && [ $RETRY -lt $MAX_RETRIES ]; do
          echo "Waiting for LoadBalancer IP... (retry $RETRY/$MAX_RETRIES)"
          sleep 10
          LB_IP=$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --ignore-not-found || true)
          RETRY=$((RETRY+1))
        done

        if [ -z "$LB_IP" ]; then
          echo "‚ùå LoadBalancer IP not found. Gathering diagnostics..."
          kubectl get svc gke-rest-api-service -o yaml || true
          kubectl describe svc gke-rest-api-service || true
          kubectl get pods -l app=gke-rest-api -o wide || true
          kubectl describe deployment gke-rest-api || true
          kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 50 || true
          exit 1
        fi

        echo "‚úÖ LoadBalancer IP: $LB_IP"

        # simple endpoint smoke check before running integration tests
        echo "‚è≥ Performing simple /products endpoint health check..."
        for i in $(seq 1 8); do
          http_status=$(curl -s -o /dev/null -w "%{http_code}" "http://$LB_IP:80/products" || echo "000")
          echo "Attempt $i: HTTP $http_status"
          if [ "$http_status" = "200" ]; then
            echo "‚úÖ /products returned 200"
            break
          fi
          sleep 5
        done

        if [ "$http_status" != "200" ]; then
          echo "‚ùå /products endpoint did not return 200 after retries. Gathering diagnostics..."
          kubectl get pods -l app=gke-rest-api -o wide || true
          kubectl describe deployment gke-rest-api || true
          kubectl describe svc gke-rest-api-service || true
          kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 50 || true
          exit 1
        fi

        # Run integration test script from the repo (script returns non-zero on failure)
        echo "üß™ Running integration tests script tests/integration_test.sh"
        chmod +x tests/integration_test.sh || true
        LB="$LB_IP" bash tests/integration_test.sh

        echo "‚úÖ Integration tests passed."

        # Optionally create a Cloud Monitoring uptime check (only if trigger sets substitution _CREATE_UPTIME_CHECK=true)
        if [ "${_CREATE_UPTIME_CHECK:-false}" = "true" ]; then
          echo "üîî Creating/updating Cloud Monitoring uptime check for /products (requires proper IAM)"
          # This uses the alpha gcloud command; adjust as needed and ensure Cloud Monitoring API is enabled
          gcloud alpha monitoring uptime-checks create http \
            --project=my-project-app-477009 \
            --display-name="gke-rest-api-products" \
            --host="$LB_IP" \
            --path="/products" \
            --port=80 \
            --http-check-response-code=200 \
            --timeout=10s \
            --period=300s || echo "‚ö†Ô∏è Could not create uptime check (insufficient permissions or alpha APIs not enabled)."
        else
          echo "Monitoring creation skipped (set _CREATE_UPTIME_CHECK=true to enable)."
        fi

images:
  - 'us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api:latest'
