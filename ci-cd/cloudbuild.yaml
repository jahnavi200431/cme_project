options:
  logging: CLOUD_LOGGING_ONLY

serviceAccount: "projects/my-project-app-477009/serviceAccounts/433503387155-compute@developer.gserviceaccount.com"

substitutions:
  _TAG: $SHORT_SHA
  _IMAGE: "us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api"
  _DB_INSTANCE_CONNECTION: "my-project-app-477009:us-central1:product-db-instance"
  _DB_PORT: "5432"

availableSecrets:
  secretManager:
    - versionName: "projects/433503387155/secrets/cloud_sql_key/versions/latest"
      env: "_CLOUD_SQL_KEY"

steps:
  # ------------------------------------------------------
  # 0) Initialize DB via Cloud SQL Proxy
  # ------------------------------------------------------
  - name: gcr.io/cloud-builders/bash
    id: "Init DB via Cloud SQL Proxy"
    secretEnv: ["_CLOUD_SQL_KEY"]
    entrypoint: bash
    args:
      - "-c"
      - |
        echo "üîê Writing service account key..."
        echo "$_CLOUD_SQL_KEY" > /tmp/cloud_sql_key.json

        echo "üöÄ Starting Cloud SQL Proxy..."
        ./cloud_sql_proxy -instances=${_DB_INSTANCE_CONNECTION}=tcp:${_DB_PORT} \
          -credential_file=/tmp/cloud_sql_key.json &

        # local variable only
        PROXY_PID=$!
        sleep 5  # give proxy time to start

        echo "üîß Loading environment variables from .env..."
        if [ -f .env ]; then
          set -o allexport
          source .env
          set +o allexport
        fi

        cd app
        pip install -r requirements.txt

        export DB_HOST=127.0.0.1
        export DB_PORT=${_DB_PORT}

        echo "üöÄ Initializing DB..."
        INIT_DB_ONLY=true python app.py

        echo "üõë Stopping Cloud SQL Proxy..."
        kill $PROXY_PID

  # ------------------------------------------------------
  # 1) Terraform Init & Apply
  # ------------------------------------------------------
  - name: hashicorp/terraform:1.6.6
    entrypoint: sh
    id: "Terraform Init & Apply"
    args:
      - "-c"
      - |
        cd infra1
        echo "üîß Initializing Terraform..."
        terraform init -input=false

        echo "üìÑ Planning Terraform..."
        terraform plan -out=tfplan -input=false

        echo "üöÄ Applying Terraform..."
        terraform apply -input=false -auto-approve tfplan

  # ------------------------------------------------------
  # 2) Build Docker Image
  # ------------------------------------------------------
  - name: gcr.io/cloud-builders/docker
    id: "Build Docker Image"
    args: ["build", "-t", "${_IMAGE}:${_TAG}", "."]

  # ------------------------------------------------------
  # 3) Push Docker Image
  # ------------------------------------------------------
  - name: gcr.io/cloud-builders/docker
    id: "Push Docker Image"
    args: ["push", "${_IMAGE}:${_TAG}"]

  # ------------------------------------------------------
  # 4) Deploy to GKE
  # ------------------------------------------------------
  - name: gcr.io/cloud-builders/gcloud
    id: "Deploy to GKE"
    entrypoint: bash
    args:
      - "-c"
      - |
        echo "üöÄ Starting deployment to GKE..."
        gcloud container clusters get-credentials product-gke-cluster \
          --zone=us-central1-a \
          --project=my-project-app-477009

        echo "üì¶ Applying Kubernetes manifests..."
        kubectl apply -f k8s/db-secret.yaml
        kubectl apply -f k8s/deployment.yaml

        echo "üîÑ Updating Deployment image: ${_IMAGE}:${_TAG}"
        kubectl set image deployment/gke-rest-api gke-rest-api=${_IMAGE}:${_TAG}

        echo "‚è≥ Waiting for rollout..."
        kubectl rollout status deployment/gke-rest-api --timeout=120s || (
          echo "‚ùå Rollout failed"
          kubectl describe deployment gke-rest-api
          kubectl get pods -o wide
          exit 1
        )

  # ------------------------------------------------------
  # 5) Post-deployment checks & integration tests
  # ------------------------------------------------------
  - name: gcr.io/cloud-builders/gcloud
    id: "Post-Deployment Checks & Integration Tests"
    entrypoint: bash
    env:
      - API_KEY=chinnu31
    args:
      - "-c"
      - |
        set -euo pipefail

        echo " Running post-deployment checks..."
        LB_IP=$$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --ignore-not-found || true)

        MAX_RETRIES=12
        RETRY=0

        while [ -z "$$LB_IP" ] && [ $$RETRY -lt $$MAX_RETRIES ]; do
          echo "Waiting for LoadBalancer IP... (retry $$RETRY/$$MAX_RETRIES)"
          sleep 10
          LB_IP=$$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' --ignore-not-found || true)
          RETRY=$$((RETRY+1))
        done

        if [ -z "$$LB_IP" ]; then
          echo "LoadBalancer IP not found. Dumping diagnostics..."
          kubectl get svc gke-rest-api-service -o yaml || true
          kubectl describe svc gke-rest-api-service || true
          kubectl get pods -l app=gke-rest-api -o wide || true
          kubectl describe deployment gke-rest-api || true
          kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 50 || true
          exit 1
        fi

        echo "LoadBalancer IP resolved: $$LB_IP"

        echo "‚è≥ Checking /products endpoint..."
        for i in $$(seq 1 8); do
          http_status=$$(curl -s -o /dev/null -w "%{http_code}" "http://$$LB_IP/products" || echo "000")
          echo "Attempt $$i: HTTP $$http_status"
          if [ "$$http_status" = "200" ]; then
            echo " /products returned 200 OK"
            break
          fi
          sleep 5
        done

        if [ "$$http_status" != "200" ]; then
          echo "/products endpoint failing."
          kubectl get pods -l app=gke-rest-api -o wide || true
          kubectl describe deployment gke-rest-api || true
          exit 1
        fi

        echo "Running integration tests..."
        chmod +x tests/integration_test.sh || true
        LB="$$LB_IP" bash tests/integration_test.sh

        echo "Integration tests passed."

images:
  - "${_IMAGE}:${_TAG}"
