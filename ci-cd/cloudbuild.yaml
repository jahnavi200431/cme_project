options:
  logging: CLOUD_LOGGING_ONLY

serviceAccount: "projects/my-project-app-477009/serviceAccounts/433503387155-compute@developer.gserviceaccount.com"

substitutions:
  _TAG: $SHORT_SHA
  _IMAGE: "us-central1-docker.pkg.dev/my-project-app-477009/my-artifact-repo/gke-rest-api"
  _DB_INSTANCE_CONNECTION: "my-project-app-477009:us-central1:product-db-instance"
  _DB_PORT: "5432"

availableSecrets:
  secretManager:
    - versionName: "projects/433503387155/secrets/cloud_sql_key/versions/latest"
      env: "_CLOUD_SQL_KEY"

steps:
  # ------------------------------------------------------
  # 0) Start Cloud SQL Proxy (pre-built container)
  # ------------------------------------------------------
  - name: 'gcr.io/cloudsql-docker/gce-proxy:1.33.2'
    id: 'Cloud SQL Proxy'
    secretEnv: ['_CLOUD_SQL_KEY']
    entrypoint: '/cloud_sql_proxy'
    args:
      - '-instances=$my-project-app-477009:us-central1:product-db-instance=tcp:5432'
      - '-credential_file=/secrets/cloudsql/_CLOUD_SQL_KEY'
    volumes:
      - name: 'cloudsql-secret'
        path: '/secrets/cloudsql'

  # ------------------------------------------------------
  # 1) Terraform Init & Apply
  # ------------------------------------------------------
  - name: hashicorp/terraform:1.6.6
    id: "Terraform Init & Apply"
    entrypoint: "sh"
    args:
      - "-c"
      - |
        cd infra1
        terraform init -input=false
        terraform plan -out=tfplan -input=false
        terraform apply -input=false -auto-approve tfplan

  # ------------------------------------------------------
  # 2) Initialize Database via Cloud SQL Proxy
  # ------------------------------------------------------
  - name: python:3.11
    id: "Init Database"
    entrypoint: bash
    secretEnv: ['_CLOUD_SQL_KEY']
    args:
      - "-c"
      - |
        if [ -f .env ]; then
          set -o allexport
          source .env
          set +o allexport
        else
          echo ".env file not found!"
          exit 1
        fi

        cd app
        pip install -r requirements.txt

        export DB_HOST=127.0.0.1
        export DB_PORT=${_DB_PORT}

        INIT_DB_ONLY=true python app.py

  # ------------------------------------------------------
  # 3) Build Docker Image
  # ------------------------------------------------------
  - name: gcr.io/cloud-builders/docker
    id: "Build Docker Image"
    args: ["build", "-t", "${_IMAGE}:${_TAG}", "."]

  # ------------------------------------------------------
  # 4) Push Docker Image
  # ------------------------------------------------------
  - name: gcr.io/cloud-builders/docker
    id: "Push Docker Image"
    args: ["push", "${_IMAGE}:${_TAG}"]

  # ------------------------------------------------------
  # 5) Deploy to GKE
  # ------------------------------------------------------
  - name: gcr.io/cloud-builders/gcloud
    id: "Deploy to GKE"
    entrypoint: bash
    args:
      - "-c"
      - |
        gcloud container clusters get-credentials product-gke-cluster \
          --zone=us-central1-a \
          --project=my-project-app-477009

        kubectl apply -f k8s/db-secret.yaml
        kubectl apply -f k8s/deployment.yaml

        kubectl set image deployment/gke-rest-api gke-rest-api=${_IMAGE}:${_TAG}
        kubectl rollout status deployment/gke-rest-api --timeout=120s

  # ------------------------------------------------------
  # 6) Post-deployment checks & integration tests
  # ------------------------------------------------------
  - name: gcr.io/cloud-builders/gcloud
    id: 'Post-Deployment Checks & Integration Tests'
    entrypoint: bash
    env:
      - API_KEY=chinnu31
    args:
      - "-c"
      - |
        set -euo pipefail

        LB_IP=$$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true)
        retries=12
        count=0
        while [ -z "$$LB_IP" ] && [ $$count -lt $$retries ]; do
          sleep 10
          LB_IP=$$(kubectl get svc gke-rest-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true)
          count=$$((count+1))
        done

        if [ -z "$$LB_IP" ]; then
          echo "LoadBalancer IP not found."
          exit 1
        fi

        echo "LoadBalancer IP: $$LB_IP"

        # Check /products endpoint
        for i in $$(seq 1 8); do
          http_status=$$(curl -s -o /dev/null -w "%{http_code}" "http://$$LB_IP/products" || echo "000")
          if [ "$$http_status" = "200" ]; then break; fi
          sleep 5
        done

        if [ "$$http_status" != "200" ]; then
          echo "/products endpoint failing."
          exit 1
        fi

        # Run integration tests
        chmod +x tests/integration_test.sh || true
        LB="$$LB_IP" bash tests/integration_test.sh

images:
  - "${_IMAGE}:${_TAG}"
